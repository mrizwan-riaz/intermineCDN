(function(root) {
    if (typeof jQuery === 'undefined') {
        return null; 
    }
    var $ = jQuery;
    // jQuery.XDomainRequest.js
    // Author: Jason Moon - @JSONMOON
    // IE8+
    // see: https://github.com/MoonScript/jQuery-ajaxTransport-XDomainRequest
    if (!$.support.cors && window.XDomainRequest) {
        var httpRegEx = /^https?:\/\//i;
        var getOrPostRegEx = /^get|post$/i;
        var sameSchemeRegEx = new RegExp('^'+location.protocol, 'i');
        var jsonRegEx = /\/json/i;
        var xmlRegEx = /\/xml/i;

        var XDomainTransporter = function (userOptions, options) {
            this.userOptions = userOptions;
            this.options = options;
            this.userType = (userOptions.dataType||'').toLowerCase();
            _.bindAll(this);
        };
        XDomainTransporter.prototype.constructor = XDomainTransporter;
        XDomainTransporter.prototype.send = function(headers, complete) {
            this.xdr = new XDomainRequest();
            this.complete = complete;
            var xdr = this.xdr;
            if (/^\d+$/.test(this.userOptions.timeout)) {
                xdr.timeout = this.userOptions.timeout;
            }
            xdr.ontimeout = function() {
                complete(500, 'timeout');
            };
            xdr.onerror = function() {
                complete(500, 'error', { text: xdr.responseText });
            };
            xdr.onload = this.onLoad;
            var postData = (this.userOptions.data && $.param(this.userOptions.data)) || '';
            xdr.open(this.options.type, this.options.url);
            xdr.send(postData);
        };
        XDomainTransporter.prototype.abort = function() {
            if (xdr) {
                xdr.abort();
            }
        };
        XDomainTransporter.prototype.onLoad = function() {
            var xdr = this.xdr;
            var allResponseHeaders = 'Content-Length: ' + xdr.responseText.length + '\r\nContent-Type: ' + xdr.contentType;
            var status = {code: 200, message: 'success'};
            var responses = {text: xdr.responseText};
            try {
                if ((this.userType === 'json') || ((this.userType !== 'text') && jsonRegEx.test(xdr.contentType))) {
                    try {
                        responses.json = $.parseJSON(xdr.responseText);
                    } catch (e) {
                        status.code = 500;
                        status.message = 'parseerror';
                    }
                } else if ((this.userType === 'xml') || ((this.userType !== 'text') && xmlRegEx.test(xdr.contentType))) {
                    var doc = new ActiveXObject('Microsoft.XMLDOM');
                    doc.async = false;
                    try {
                        doc.loadXML(xdr.responseText);
                    } catch(e) {
                        doc = undefined;
                    }
                    if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
                        status.code = 500;
                        status.message = 'parseerror';
                        throw 'Invalid XML: ' + xdr.responseText;
                    }
                    responses.xml = doc;
                }
            } catch (parseMessage) {
                throw parseMessage;
            } finally {
                this.complete(status.code, status.message, responses, allResponseHeaders);
            }
        };

        // ajaxTransport exists in jQuery 1.5+
        jQuery.ajaxTransport('text html xml json', function(options, userOptions, jqXHR){
            // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page
            if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(userOptions.url) && sameSchemeRegEx.test(userOptions.url)) {
                return new XDomainTransporter(userOptions, options);
            }
        });
        $.support.cors = true;
    }
}).call(this, typeof exports === 'undefined' ? this : exports);
// Generated by CoffeeScript 1.3.3
(function() {
  var root, _base, _ref, _ref1,
    __slice = [].slice;

  if (Array.prototype.map == null) {
    Array.prototype.map = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        _results.push(f(x));
      }
      return _results;
    };
  }

  if (Array.prototype.filter == null) {
    Array.prototype.filter = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  }

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function(f, initValue) {
      var ret, x, xs, _i, _len;
      xs = this.slice();
      ret = initValue != null ? initValue : xs.pop();
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        ret = f(ret, x);
      }
      return ret;
    };
  }

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === "undefined" || exports === null) {
    if ((_ref = root.intermine) == null) {
      root.intermine = {};
    }
    if ((_ref1 = (_base = root.intermine).funcutils) == null) {
      _base.funcutils = {};
    }
    root = root.intermine.funcutils;
  }

  root.fold = function(init, f) {
    return function(xs) {
      var k, ret, v;
      if (xs.reduce != null) {
        return xs.reduce(f, init);
      } else {
        ret = init;
        for (k in xs) {
          v = xs[k];
          ret = ret != null ? f(ret, k, v) : {
            k: v
          };
        }
        return ret;
      }
    };
  };

  root.take = function(n) {
    return function(xs) {
      if (n != null) {
        return xs.slice(0, (n - 1) + 1 || 9e9);
      } else {
        return xs;
      }
    };
  };

  root.omap = function(f) {
    return function(o) {
      var domap;
      domap = exports.fold({}, function(a, k, v) {
        var kk, vv, _ref2;
        _ref2 = f(k, v), kk = _ref2[0], vv = _ref2[1];
        a[kk] = vv;
        return a;
      });
      return domap(o);
    };
  };

  root.partition = function(f) {
    return function(xs) {
      var falses, trues, x, _i, _len;
      trues = [];
      falses = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          trues.push(x);
        } else {
          falses.push(x);
        }
      }
      return [trues, falses];
    };
  };

  root.concatMap = function(f) {
    return function(xs) {
      var fx, k, ret, v, x, _i, _len;
      ret = void 0;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        fx = f(x);
        ret = (function() {
          if (ret === void 0) {
            return fx;
          } else if (typeof fx === 'string') {
            return ret + fx;
          } else if (fx.slice != null) {
            return ret.concat(fx);
          } else {
            for (k in fx) {
              v = fx[k];
              ret[k] = v;
            }
            return ret;
          }
        })();
      }
      return ret;
    };
  };

  root.AND = function(a, b) {
    return a && b;
  };

  root.OR = function(a, b) {
    return a || b;
  };

  root.NOT = function(x) {
    return !x;
  };

  root.id = function(x) {
    return x;
  };

  root.invoke = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function(obj) {
      return obj[name].apply(obj, args);
    };
  };

  root.invokeWith = function(name, args, ctx) {
    if (args == null) {
      args = [];
    }
    if (ctx == null) {
      ctx = null;
    }
    return function(o) {
      return o[name].apply(ctx || o, args);
    };
  };

  root.get = function(name) {
    return function(obj) {
      return obj[name];
    };
  };

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    /**
     * A module for encapsulating the metadata available to a
     * client.
     * @module intermine/Model
     */

    var _, Deferred;
    if (IS_NODE) {
        _ = require('underscore')._;
        Deferred = require('jquery-deferred').Deferred;
    } else {
        _ = exports._;
        Deferred = exports.jQuery.Deferred;
        if (typeof exports.intermine === 'undefined') {
            exports.intermine = {};
        }
        exports = exports.intermine;
    } 

    /**
     * A representation of the information contained in a path
     * expression. This class exposes the metadata available for this
     * path, and is aware of class constraints placed upon it.
     * @constructor
     * @param {Object} info The initial information used to construct this path.
     */
    var PathInfo = function(info) {
        _(this).extend(info);
        this.end = _(this.descriptors).last();
    };
    PathInfo.prototype.constructor = PathInfo;

    PathInfo.prototype.isRoot = function() {
        return this.descriptors.length == 0;
    };

    PathInfo.prototype.getEndClass = function() {
        var endClassName, endClass = null;
        if (this.isRoot()) {
            endClass = this.root;
        } else if (this.isClass()) {
            endClassName = this.subclasses[this.toString()] || this.end.referencedType;
            endClass = this.model.classes[endClassName];
        }
        return endClass;
    };

    PathInfo.prototype.getParent = function() {
        if (this.isRoot()) {
            throw "Root paths do not have a parent";
        }
        var data = _.extend({}, this, {descriptors: _(this.descriptors).initial(), displayName: null});
        return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
        var type = this.getType();
        if (_(attr).isString()) {
            attr = type.fields[attr];
        }
        var data = _.extend({}, this, {descriptors: this.descriptors.concat([attr]), displayName: null});
        return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
        var className = (clazz.name) ? clazz.name : clazz + "";
        var type = this.getType();
        var ancestors;
        if (className === type.name) {
            return true;
        } else {
            ancestors = this.model.getAncestorsOf(type);
            return _(ancestors).include(className);
        }
    };

    var _displayNameCache = {};

    PathInfo.prototype.getDisplayName = function(cb) {
        var wrapped, promise, self = this;
        var cacheKey = this.toString() + ":" + _.map(this.subclasses, function(v, k) {return k + "=" + v}).join(';');
        var displayName;
        if (this.displayName != null || _displayNameCache[cacheKey] != null) {
            promise = new Deferred();
            displayName = (this.displayName || _displayNameCache[cacheKey]);
            if (cb != null) {
                cb(displayName);
            }
            promise.resolve(displayName);
            return promise;
        }
            this.displayName = _displayNameCache[cacheKey];
        if (cb == null) {
            wrapped = function() {};
        } else {
            wrapped = function(resp) {
                self.displayName = resp.display;
                _displayNameCache[cacheKey] = resp.display;
                cb(resp.display);
            };
        }
        if (this.model.service == null) {
            throw new Error("Cannot fetch display name: no service");
        }
        var params = {format: 'json'};
        _.each(this.subclasses, function(v, k) {
            params[k] = v;
        });
        var slashPath = _.reduce(this.descriptors, function(a, d) { return a + "/" + d.name }, "/" + this.root.name);
        return this.model.service.makeRequest('model' + slashPath, params, wrapped);
    };

    PathInfo.prototype.getChildNodes = function() {
        var cls, flds, childNodes, i, l;
        childNodes = [];
        var self = this;
        if (!this.isAttribute()) {
            cls = this.getEndClass();
            flds = cls.fields;
            _.each(flds, function(fld, name) {
                childNodes.push(self.append(fld));
            });
        } 
        return childNodes;
    };


    var pistr = function() {
        var str = this.root.name;
        return _(this.descriptors).reduce(function(a, b) {return a + "." + b.name}, this.root.name);
    };

    PathInfo.prototype.toPathString = pistr;
    PathInfo.prototype.toString = pistr;

    PathInfo.prototype.isAttribute = function() {
        if (this.isRoot()) {
            return false;
        }
        return this.end && !this.end.referencedType;
    };


    PathInfo.prototype.isClass = function() {
        if (this.isRoot()) {
            return true;
        }
        return this.end && this.end.referencedType;
    };

    PathInfo.prototype.isReference = function() {
        return this.end && this.end.referencedType;
    };

    PathInfo.prototype.isCollection = function() {
        return this.end && this.end.isCollection;
    };

    PathInfo.prototype.containsCollection = function() {
        if (this.isRoot()) {
            return false;
        }
        return _(this.descriptors).any(function(d) {
            return d.isCollection;
        });
    };

    var Table = function(o) {
        _(this).extend(o);
        _(this.collections).each(function(coll) {
            coll.isCollection = true;
        });
        this.fields = _({}).extend(this.attributes, this.references, this.collections);
        this.allReferences = _({}).extend(this.references, this.collections);
    };

    // TODO: write unit tests.
    /**
        * Get the type of an attribute path. If the path represents a class or a reference, 
        * the class itself is returned, otherwise the name of the attribute type is returned, 
        * minus any "java.lang." prefix.
        *
        * @param path The path to get the type of
        * @return A class-descriptor, or an attribute type name.
        */
    PathInfo.prototype.getType = function() {
        return this.getEndClass() || this.end.type.replace(/java\.lang\./, "");
    };

    Table.prototype = {
        constructor: Table
    };

    Table.prototype.toString = function toString() {
        return "[Table name=" + this.name + "]"
    };

    var Model = function(model) {
        _(this).extend(model);

        // Promote classes to tables.
        var classes = this.classes;
        _(classes).each(function(cd, name) {
            classes[name] = new Table(cd);
        });

    };

    Model.prototype.constructor = Model;

    /**
    * Get the ClassDescriptor for a path. If the path is a root-path, it 
    * returns the class descriptor for the class named, otherwise it returns 
    * the class the last part resolves to. If the last part is an attribute, this
    * function returns "undefined".
    *
    * @param path The path to resolve.
    * @return A class descriptor object, or undefined.
    */
    Model.prototype.getCdForPath = function(path) {
        var parts = path.split(".");
        var cd = this.classes[parts.shift()];
        return _(parts).reduce(_(function (memo, fieldName) {
            var fields = _({}).extend(
                memo.attributes, memo.references, memo.collections);
            return this.classes[fields[fieldName].referencedType];
        }).bind(this), cd);
    };

    // TODO: write unit tests
    /**
        * Get an object describing the path defined by the arguments.
        *
        * @param path The path to be described.
        * @param subclasses An object mapping path {Str} -> type {Str}
        */
    Model.prototype.getPathInfo = function(path, subclasses) {
        var cacheKey, pathInfo, parts, cd, keyPath, ret, self = this;
        subclasses = subclasses || {};
        cacheKey = path + _.map(subclasses, function(v,k) {return k+"="+v; }).join(':');
        if (this.__pathinfos == null) {
            this.__pathinfos = {};
        }
        if (this.__pathinfos[cacheKey] != null) {
            return this.__pathinfos[cacheKey];
        }
        pathInfo = {};
        parts = path.split(".");
        cd = this.classes[parts.shift()];
        keyPath = cd.name;
        pathInfo.root = cd;
        pathInfo.model = this;
        pathInfo.descriptors = _(parts).map(function(fieldName) {
            var fields = _({}).extend(cd.attributes, cd.references, cd.collections);
            if (!fields[fieldName]) {
                cd = self.classes[subclasses[keyPath]];
                try {
                    fields = _({}).extend(cd.attributes, cd.references, cd.collections);
                } catch (e) {
                    throw new Error("Could not resolve " + path);
                }
            }
            keyPath += "." + fieldName;
            var fd = fields[fieldName];
            cd = fd.referencedType ? self.classes[fd.referencedType] : null;
            return fd;
        });
        pathInfo.subclasses = subclasses;

        ret = new PathInfo(pathInfo);
        this.__pathinfos[cacheKey] = ret;
        return ret;

    };



    // TODO: write unit tests.
    // TODO - move all uses to PathInfo
    /**
        * Determine if there are any collections mentioned in the given path. 
        * eg: 
        *   Department.employees.name -> true
        *   Department.company.name -> false
        *
        * @param path {String} The path to examine.
        * @return {Boolean} Whether or not there is any collection in the path.
        */
    Model.prototype.hasCollection = function(path) {
        var paths = []
            ,parts = path.split(".")
            ,bit, parent, cd;
        while (bit = parts.pop()) {
            parent = parts.join(".");
            if ((parent) && (cd = this.getCdForPath(parent))) {
                if (cd.collections[bit]) {
                    return true;
                }
            }
        }
        return false;
    };

    var _subclass_map = {};

    /**
        * Return the subclasses of a given class. The subclasses of a class
        * includes the class itself, and is thus equivalent to 
        * 'isAssignableTo' in java.
        */
    Model.prototype.getSubclassesOf = function(cls) {
        var self = this;
        if (cls in _subclass_map) {
            return _subclass_map[cls];
        }
        var ret = [cls];
        _(this.classes).each(function(c) {
            if (_(c["extends"]).include(cls)) {
                ret = ret.concat(self.getSubclassesOf(c.name));
            }
        });
        _subclass_map[cls] = ret;
        return ret;
    };

    /**
    * Get the full ancestry of a particular class.
    *
    * The returned ancestry never includes the root InterMineObject base class.
    */
    Model.prototype.getAncestorsOf = function(clazz) {
        clazz = (clazz && clazz.name) ? clazz : this.classes[clazz + ""];
        var ancestors = clazz["extends"].slice();
        _(ancestors).each(_(function(a) {
            if (!a.match(/InterMineObject$/)) {
                ancestors = _.union(ancestors, this.getAncestorsOf(a));
            }
        }).bind(this));
        return ancestors;
    }


    /**
    * Return the common type of two model classes, or null if there isn't one.
    */
    Model.prototype.findCommonTypeOf = function(classA, classB) {
        if (classB == null || classA == null || classA == classB) {
            return classA;
        }
        var allAncestorsOfA = this.getAncestorsOf(classA);
        var allAncestorsOfB = this.getAncestorsOf(classB);
        // If one is a superclass of the other, return it.
        if (_(allAncestorsOfA).include(classB)) {
            return classB;
        }
        if (_(allAncestorsOfB).include(classA)) {
            return classA;
        }
        // Return the first common ancestor

        return _.intersection(allAncestorsOfA, allAncestorsOfB).shift();
    };

    /**
    * Return the common type of 0 or more model classes, or null if there is none.
    *
    * @param model The data model for this service.
    * @classes {String[]} classes the model classes to try and get a common type of.
    */
    Model.prototype.findCommonTypeOfMultipleClasses = function(classes) {
        return _.reduce(classes, _(this.findCommonTypeOf).bind(this), classes.pop());
    };
    Model.NUMERIC_TYPES = ["int", "Integer", "double", "Double", "float", "Float"];
    Model.INTEGRAL_TYPES = ["int", "Integer"]
    Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

    exports.Model = Model;
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');

// Generated by CoffeeScript 1.3.3

/*
# @source: /src/user.coffee
#
# The User class represents the authenticated user's profile
# information. It provides access to methods to read an manipulate
# a user's preferences.
#
# @author: Alex Kalderimis
*/


(function() {
  var Deferred, IS_NODE, User, root, _;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === 'undefined') {
    IS_NODE = false;
    Deferred = root.jQuery.Deferred;
    _ = root._;
    if (typeof root.console === 'undefined') {
      root.console = {
        log: function() {},
        error: function() {}
      };
    }
    if (root.intermine === 'undefined') {
      root.intermine = {};
    }
    root = root.intermine;
  } else {
    IS_NODE = true;
    Deferred = require('jquery-deferred').Deferred;
    _ = require('underscore')._;
  }

  User = (function() {

    function User(service, _arg) {
      var _ref;
      this.service = service;
      this.username = _arg.username, this.preferences = _arg.preferences;
      this.hasPreferences = this.preferences != null;
      if ((_ref = this.preferences) == null) {
        this.preferences = {};
      }
    }

    User.prototype.setPreference = function(key, value) {
      var data;
      if (_.isString(key)) {
        data = {};
        data[key] = value;
      } else if (!(value != null)) {
        data = key;
      } else {
        return Deferred().reject("bad-arguments", "Incorrect arguments to setPreference");
      }
      return this.setPreferences(data);
    };

    User.prototype.setPreferences = function(prefs) {
      return this._do_pref_req(prefs, 'POST');
    };

    User.prototype.clearPreference = function(key) {
      return this._do_pref_req({
        key: key
      }, 'DELETE');
    };

    User.prototype.clearPreferences = function() {
      return this._do_pref_req({}, 'DELETE');
    };

    User.prototype.refresh = function() {
      return this._do_pref_req({}, 'GET');
    };

    User.prototype._do_pref_req = function(data, method) {
      var _this = this;
      return this.service.manageUserPreferences(method, data).done(function(prefs) {
        return _this.preferences = prefs;
      });
    };

    return User;

  })();

  root.User = User;

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    var Model, Query, List, _, Deferred, User, ACCEPT_HEADER;
    ACCEPT_HEADER = {
        "json": "application/json",
        "jsonobjects": "application/json;type=objects",
        "jsontable": "application/json;type=table",
        "jsonrows": "application/json;type=rows",
        "jsoncount": "application/json;type=count",
        "jsonp": "application/javascript",
        "jsonpobjects": "application/javascript;type=objects",
        "jsonptable": "application/javascript;type=table",
        "jsonprows": "application/javascript;type=rows",
        "jsonpcount": "application/javascript;type=count"
    };
    if (IS_NODE) {
        _ = require('underscore')._;
        Deferred = require('jquery-deferred').Deferred;
        var http     = require('http');
        var URL      = require('url');
        var qs       = require('querystring');
        Model        = require('./model').Model;
        Query        = require('./query').Query;
        List         = require('./lists').List;
        User         = require('./user').User;
        var EventEmitter = require('events').EventEmitter;
        var BufferedResponse = require('buffered-response').BufferedResponse;
    } else {
        _ = exports._;
        Deferred = exports.jQuery.Deferred;
        if (typeof exports.intermine === 'undefined') {
            exports.intermine = {};
        }
        exports = exports.intermine;
        var converters = {};
        _.each(_.keys(ACCEPT_HEADER), function(dataType) {
            converters["text " + dataType] = jQuery.parseJSON;
        });
        jQuery.ajaxSetup({accepts: ACCEPT_HEADER, contents: {json: /json/}, converters: converters});
    } 

    // The classes defined here are for exporting to the 'intermine'
    // namespace.
    // @namespace
    // @exports intermine/Service
    var intermine = exports;

    var to_query_string = IS_NODE ? qs.stringify : jQuery.param;

    var MODELS = {};
    var SUMMARY_FIELDS = {};
    var slice = Array.prototype.slice;
    var DEFAULT_PROTOCOL = "http://";
    var VERSION_PATH = "version";
    var TEMPLATES_PATH = "templates";
    var LISTS_PATH = "lists";
    var MODEL_PATH = "model";
    var SUMMARYFIELDS_PATH = "summaryfields";
    var QUERY_RESULTS_PATH = "query/results";
    var QUICKSEARCH_PATH = "search";
    var WIDGETS_PATH = "widgets";
    var ENRICHMENT_PATH = "list/enrichment";
    var WITH_OBJ_PATH = "listswithobject";
    var LIST_OPERATION_PATHS = {
        merge: "lists/union",
        intersect: "lists/intersect",
        diff: "lists/diff"
    };

    // The identity function f x = x
    var IDENTITY = function(x) { return x; };

    // Pattern for detecting if URI has a protocol
    var HAS_PROTOCOL = /^https?:\/\//i;

    // Pattern for detecting if the URI has the necessary service suffix.
    var HAS_SUFFIX = /service\/?$/i;

    // The suffix all service URIs must end in.
    var SUFFIX = "/service/";

    // The constructor for the Service class takes objects with the following
    // properties:
    // @property {String} root The URL of the root of the service.
    // @property {?String} token The user's API token.
    // @property {?function({XHttpRequest}, {String}, {String})} An error handler
    
    // Which you use to construct a new service like so:
    //
    //     var service = new Service({root: "http://host/path", token: "my-token});
    //
    // @api public
    // @constructor
    // @param {ServiceParameters} properties A configuration object.
    var Service = function(properties) {

        // keep this reference for internal binding issues.
        var __service = this;

        if (typeof Model === 'undefined' && intermine) {
            Model = intermine.Model;
        }
        if (typeof Query === 'undefined' && intermine) {
            Query = intermine.Query;
        }
        if (typeof List === 'undefined' && intermine) {
            List = intermine.List;
        }
        if (typeof User === 'undefined' && intermine) {
            User = intermine.User;
        }
        
        /**
         * The kind of object that the server sends as for every
         * JSON request. A results envelope will be sent for every request, even if the
         * request is unsuccessful.
         * @name ResultsEnvelope
         * @property {boolean} wasSuccessful Whether or not this request was successful. This
         *           property should be checked for streaming requests (such as query results),
         *           as errors can occur while results are being processed.
         * @property {int} statusCode The HTTP error code.
         * @property {String} error A human-readable error message saying what went wrong.
         * @property {String} executionTime The time when this result set was generated. eg: 2012.11.02 16:00::16
         */

        var wrapErrorHandler = function(handler) { return function(xhr, textStatus, e) {
            try {
                return JSON.parse(xhr.responseText);
            } catch (parseError) {
                return textStatus;
            }
        }};

        /**
         * A function that can be passed as the callback to handle
         * the successful completion of an HTTP service request.
         * @name SuccessCallback
         * @param data {ResultsEnvelope} The data received from the server.
         * @return void
         */

        /**
         * A function to wrap an optional callback which extracts
         * a specific property from a results envelope and passes it into
         * the callback if it exists and returns the extracted value.
         * @name ResultProcessor
         * @param cb {ItemProcessor} The optional callback
         * @return {SuccessCallback} A success callback.
         */

        /**
         * A function that handles the results returned from as server call.
         * @name ItemProcessor
         * @param item The item to process
         * @param data {ResultsEnvelope} The original envelope, possibly containing metadata.
         */

        /**
         * A function to generate a function that wraps an optional callback and passes into
         * it the value of a specific property of the first argument passed in, returning that
         * value.
         * @private
         * @param key The key to extract from the eventual results object.
         * @return {ResultProcessor} A result processor.
         */
        var getResultProcessor = function(key) { return function(cb) { return function(response) {
            var deferred = Deferred(), item = response[key];
            if (!response.wasSuccessful) {
                deferred.reject(response.error);
            } else {
                (cb || IDENTITY)(item, response);
                deferred.resolve(item, response);
            }
            return deferred.promise();
        }}};

        /**
         * A function to wrap an optional callback which extracts the
         * 'results' property from the results envelope and passes it into
         * the callback if it exists and returns the extracted value.
         * @private
         * @param cb {function} The optional callback
         * @return Whatever the value of the 'results' property is.
         */
        var getResulteriser = getResultProcessor('results');

        // Compute this just once; it cannot change.
        var location = (IS_NODE) ? '' : window.location.protocol + '//' + window.location.host;

        /**
         * Get the format for a request, given a default.
         * Basically this function is here to make sure that
         * we do jsonp requests when we have to.
         * @private
         * @param def The default format for this request.
         */
        var getFormat = function(def) {
            var format = def || "json";
            if (!(IS_NODE || jQuery.support.cors)) {
                if (!location.substring(0, __service.root.length) === __service.root) {
                    // X-Domain, but no CORS support: fallback to json-p
                    format = format.replace("json", "jsonp");
                }
            }
            return format;
        };

        /**
         * Short-cut for the common POST operation. For more fine-grained
         * request handling use makeRequest.
         * @this {Service}
         * @param path {string} The path to the resource to post to.
         * @param data {Object} The data to post to the resource.
         * @param cb {function} An optional callback.
         * @return {Deferred} A promise to perform this action.
         */
        this.post = function(path, data, cb) {
            return this.makeRequest(path, data, cb, 'POST');
        };

        /**
         * Short-cut for the common GET operation. For more fine-grained
         * request handling use makeRequest.
         * @this {Service}
         * @param {string} path The path to the resource to post to.
         * @param {Object.<string, string>} data An optional set of data to send to the server.
         * @param {SuccessCallback} cb An optional callback.
         * @return {Deferred} A promise to perform this action.
         */
        this.get = function(path, data, cb) {
            if(!cb && data && _.isFunction(data)) {
                cb = data; // Allow calling with get(path, cb);
                data = {};
            }
            return this.makeRequest(path, data, cb, 'GET');
        }

        /**
         * The valid HTTP request methods: 'GET', 'POST', 'PUT', 'DELETE'
         * @name RequestMethod
         * @enum {String}
         */

        /**
        * Performs a get request for data against a url. 
        * This method makes use of jsonp where available.
        * @name makeRequest
        * @param {String} path The entrypoint of the service.
        * @param {Object.<String, String>=} Optional data to send as parameters (default = {}).
        * @param {SuccessCallback=} cb An optional success callback (default = IDENTITY).
        * @param {RequestMethod=} method The method to call the entry point with. (default = "GET")
        * @param {boolean=} itemByItem Whether or not this request requires individual processing.
        * @return {Deferred} A promise to make a request.
        */
        this.makeRequest = function(path, data, cb, method, itemByItem) {
            method = (method || "GET");
            cb = (cb || IDENTITY);
            data = (data || {});
            var url   = this.root + path;
            var errorCB = this.errorHandler;
            if (cb[0] && cb[1]) {
                errorCB = cb[1];
                cb = cb[0];
            }

            if (_.isArray(data)) { // We also accept lists of pairs.
                data = _.foldl(data, function(m, pair) { m[pair[0]] = pair[1]; return m;}, {});
            }

            if (this.token) {
                data.token = this.token;
            }
            data.format = getFormat(data.format);

            if (/jsonp/.test(data.format)) {
                // Tunnel the method in a parameter.
                data.method = method;
                method = "GET"; 
                url += "?callback=?";
            }
            // IE requires that we tunnel DELETE and PUT requests.
            if (!this.supports(method)) {
                data.method = method;
                method = this.getEffectiveMethod(method);
            }

            if (method === "DELETE") {
                // grumble grumble struts grumble grumble...
                // (struts won't read query data from the request body
                // of DELETE requests).
                url += "?" + to_query_string(data);
            }

            return this.doReq({
                data: data,
                dataType: data.format,
                success: cb,
                error: errorCB,
                url: url,
                type: method
            }, itemByItem);
        };

        this.supports = function() { return true; };
        this.getEffectiveMethod = IDENTITY;

        if (IS_NODE) {
            this.rowByRow = function(q, page, cbs) {
                // Allow calling as rows(q, cb)
                if (_(cbs).isUndefined() && _(page).isFunction()) {
                    cbs = page;
                    page = {};
                }
                page = page || {};
                var req = _(page).extend({query: q.toXML()});
                return this.makeRequest(QUERY_RESULTS_PATH, req, cbs, 'POST', true);
            };

            this.recordByRecord = function(q, page, cbs) {
                // Allow calling as records(q, cb)
                if (_(cbs).isUndefined() && _(page).isFunction()) {
                    cbs = page;
                    page = {};
                }
                page = page || {};
                var req = _(page).extend({query: q.toXML(), format: "jsonobjects"});
                return this.makeRequest(QUERY_RESULTS_PATH, req, cbs, 'POST', true);
            };

            var PESKY_COMMA = /,\s*$/;

            var __doIterableReq = function(ret, opts) { return function(res) {
                 var iter, containerBuffer = "";
                 var char0 = (opts.data.format === 'json') ? '[' : '{';
                 var charZ = (opts.data.format === 'json') ? ']' : '}';
                 iter = new BufferedResponse(res, 'utf8')
                    .map(function(line, idx) {
                        try {
                          var parsed = JSON.parse(line.replace(PESKY_COMMA, ''));
                          return parsed;
                        } catch(e) {
                          containerBuffer += line;
                          var lastChar = line[line.length - 1];
                          if (idx > 0 && (lastChar === ',' || (lastChar === char0 && line[0] === charZ))) {
                              iter.emit('error', e, line); // should have parsed.
                          }
                          return undefined;
                        }
                    })
                   .filter(function(item) {return (!!item)})
                   .each(function(item) {
                       try {
                           opts.success(item);
                       } catch (e) {
                           iter.emit('error', e);
                           ret.reject(e);
                       }
                    })
                   .error(opts.error)
                   .done(function() {
                     try {
                         var container = JSON.parse(containerBuffer);
                         if (container.error) {
                             var e = new Error(container.error);
                             ret.reject(e);
                             iter.emit('error', e);
                         }
                     } catch (e) {
                         ret.reject(e, containerBuffer);
                         iter.emit('error', containerBuffer);
                     }
                   });
                ret.resolve(iter);
            }};
            var __doSingletonResult = function(ret, opts) { return function(res) {
                 var contentBuffer = "";
                 ret.then(opts.success);
                 res.on('data', function(chunk) {contentBuffer += chunk});
                 res.on('end', function() {
                     if (opts.data.format.match(/json/)) {
                        var parsed;
                        try {
                            parsed = JSON.parse(contentBuffer);
                            if (parsed.error) {
                                ret.reject(new Error(parsed.error));
                            } else {
                                ret.resolve(parsed);
                            }
                        } catch(e) {
                            ret.reject(new Error("Could not parse buffer (" + contentBuffer + "): " + e));
                        }
                     } else {
                         var e;
                         if (e = contentBuffer.match(/\[Error\] (\d+)(.*)/m)) {
                             ret.reject(new Error(e[2]));
                         } else {
                             ret.resolve(contentBuffer);
                         }
                     }
                 });
            }}

            this.doReq = function(opts, resultByResult) {
                var ret = new Deferred().fail(opts.error);
                var postdata = to_query_string(opts.data);
                var url = URL.parse(opts.url, true);
                url.method = opts.type;
                url.port = url.port || 80;
                url.headers = {'User-Agent': 'node-http/imjs', 'Accept': ACCEPT_HEADER[opts.dataType]};
                if (url.method === 'GET' && _(opts.data).size()) {
                    url.path += "?" + postdata;
                } else if (url.method === 'POST') {
                    url.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    url.headers['Content-Length'] = postdata.length;
                }
                var req = http.request(url, (resultByResult) ?
                    __doIterableReq(ret, opts) : __doSingletonResult(ret, opts));

                req.on('error', function(e) {
                    ret.reject(e);
                });

                if (url.method === 'POST') {
                    if (this.DEBUG) {
                        console.log("Writing data to " + url.host + "/" + url.path + ": " + postdata);
                    }
                    req.write(postdata);
                }
                req.end();
                return ret;
            };
        } else {
            this.doReq = function(opts) {
                var errorHandler = wrapErrorHandler(opts.error);
                delete opts.error;
                return jQuery.ajax(opts).pipe(IDENTITY, errorHandler);
            }
            if (typeof XDomainRequest !== 'undefined') {
                this.getEffectiveMethod = (function(mapping) {
                    return function(x) { return mapping[x]; }
                })({PUT: "POST", DELETE: "GET"});
                this.supports = function(method) {
                    return this.getEffectiveMethod(method) === method;
                };
            }
            var __wrap_cbs = function(cbs) {
                var wrappedSuccess, error;
                if (cbs[0] && cbs[1]) {
                    wrappedSuccess = function(rows) {
                        _.each(rows, cbs[0]);
                    };
                    error = cb[1];
                    return [wrappedSuccess, error];
                } else {
                    wrappedSuccess = function(rows) {
                        _.each(rows, cbs);
                    };
                    return wrappedSuccess;
                }
            };

            this.rowByRow = function(q, page, cbs) {
                page = page || {};
                var _cbs = __wrap_cbs(cbs), req = _(page).extend({query: q.toXML()});
                return this.post(QUERY_RESULTS_PATH, req, _cbs);
            };

            this.recordByRecord = function(q, page, cbs) {
                page = page || {};
                var _cbs = __wrap_cbs(cbs), req = _(page).extend({query: q.toXML(), format: "jsonobjects"});
                return this.post(QUERY_RESULTS_PATH, req, _cbs);
            };
        }
        this.eachRow = this.rowByRow;
        this.eachRecord = this.recordByRecord;

        var widgeteriser = getResultProcessor('widgets');

        this.widgets = function(cb) {
            return this.get(WIDGETS_PATH).pipe(widgeteriser(cb));
        };

        this.enrichment = function(req, cb) {
            _.defaults(req, {maxp: 0.05});
            return this.makeRequest(ENRICHMENT_PATH, req).pipe(getResulteriser(cb));
        };

        this.search = function(options, cb) {
            if (_(options).isString()) {
                options = {term: options};
            }
            if (!cb && _(options).isFunction()) {
                cb = options;
                options = {};
            }
            options = options || {};
            cb      = cb      || IDENTITY;
            _.defaults(options, {term: "", facets: {}});
            var req = {q: options.term, start: options.start, size: options.size};
            if (options.facets) {
                _(options.facets).each(function(v, k) {
                    req["facet_" + k] = v;
                });
            }
            return this.post(QUICKSEARCH_PATH, req).pipe(function(data) {
                cb(data.results, data.facets);
                return data.results;
            });
        };

        this.count = function(q, cont) {
            var req = {
                query: q.toXML(),
                format: getFormat("jsoncount")
            };
            return this.makeRequest(QUERY_RESULTS_PATH, req, null, "POST").pipe(getResultProcessor('count')(cont));
        };

        this.findById = function(table, objId, cb) {
            var promise = Deferred();
            cb = cb || IDENTITY;
            this.query({from: table, select: ["**"], where: {"id": objId}}, function(q) {
                for (var i = 0; i < q.views.length; i++) {
                    var view = q.views[i];
                    var parts = view.split('.');
                    if (parts.length > 2) {
                        q.addJoin(parts.slice(0, parts.length - 1).join('.'));
                    }
                }
                q.records(function(rs) {
                    cb(rs[0]);
                    promise.resolve(rs[0]);
                }).fail(promise.reject);
            }).fail(promise.reject);
            return promise;
        };

        this.whoami = function(cb) {
            cb = cb || IDENTITY;
            var self = this, promise = Deferred(), handler = function(resp) {
                var user = new User(self, resp.user);
                cb(user);
                promise.resolve(user);
                return user;
            };
            self.fetchVersion(function(v) {
                if (v < 9) {
                    var msg = "The who-am-i service requires version 9, this is only version " + v;
                    promise.reject("not available", msg);
                } else {
                    self.makeRequest("user/whoami").pipe(handler, promise.reject);
                }
            }).fail(promise.reject);
            return promise;
        };

        var doPagedRequest = function(path, page, cb, q, format) {
            if (_(cb).isUndefined() && _(page).isFunction()) {
                cb = page;
                page = {};
            }
            var req = _(page || {}).extend({query: q.toXML(), format: format});
            return this.post(path, req).pipe(getResulteriser(cb));
        };

        this.table = function(q, page, cb) {
            return doPagedRequest.call(this, QUERY_RESULTS_PATH, page, cb, q, "jsondatatable");
        };

        this.records = function(q, page, cb) {
            return doPagedRequest.call(this, QUERY_RESULTS_PATH, page, cb, q, "jsonobjects");
        };

        this.rows = function(q, page, cb) {
            return doPagedRequest.call(this, QUERY_RESULTS_PATH, page, cb, q, "json");
        };

        this.tableRows = function(q, page, cb) {
            return doPagedRequest.call(this, QUERY_RESULTS_PATH + '/tablerows', page, cb, q, "json");
        };

        var DEFAULT_ERROR_HANDLER = function(error) {
            if (console.error) {
                console.error(error);
            } else if (console.log) {
                console.log(error);
            }
        };

        var constructor = _.bind(function(properties) {
            var root = properties.root;
            if (!HAS_PROTOCOL.test(root)) {
                root = DEFAULT_PROTOCOL + root;
            }
            if (!HAS_SUFFIX.test(root)) {
                root = root + SUFFIX;
            }
            root = root.replace(/ice$/, "ice/");
            this.errorHandler = (properties.errorHandler || DEFAULT_ERROR_HANDLER);
            this.root = root;
            this.token = properties.token
            this.DEBUG = properties.debug || false;
            this.help = properties.help || 'no.help.available@dev.null'

            _.bindAll(this, "fetchVersion", "rows", "records", "fetchTemplates",
                "fetchLists", "fetchList", "fetchListsContaining",
                "count", "makeRequest", "fetchModel", "fetchSummaryFields",
                "combineLists", "merge", "intersect", "diff", "query", "whoami", "findById",
                "post", "get");

        }, this);

        this.fetchVersion = function(cb) {
            var self = this;
            var promise = Deferred();
            if (cb == null) {
                cb = IDENTITY;
            }
            if (typeof this.version === "undefined") {
                this.makeRequest(VERSION_PATH, null, function(data) {
                    this.version = data.version;
                    cb(this.version);
                    promise.resolve(this.version);
                }).fail(promise.reject);
            } else {
                cb(this.version);
                promise.resolve(this.version);
            }
            return promise;
        };

        this.fetchTemplates = function(cb) {
            return this.makeRequest(TEMPLATES_PATH).pipe(getResultProcessor('templates')(cb));
        };


        var listProcessor = getResultProcessor('lists')();
        var instantiate_lists = function(lists) {
            return lists.map(function(l) { return new List(l, __service); });
        };
        var listFinder = function(name) { return function(lists) {
            var ret = Deferred(), l = _.find(lists, function(l) { return l.name === name });
            if (l == null) {
                ret.reject("List not found");
            } else {
                ret.resolve(l);
            }
            return ret.promise();
        }};

        this.fetchLists = function(cb) {
            return this.makeRequest(LISTS_PATH).pipe(listProcessor).pipe(instantiate_lists).done(cb);
        };

        this.fetchList = function(name, cb) {
            return this.fetchLists().pipe(listFinder(name)).then(cb, this.errorHandler);
        }

        this.combineLists = function(operation) {
            var self = this;
            return function(options, cb) {
                var path = LIST_OPERATION_PATHS[operation],
                    params = {
                        name: options.name,
                        tags: options.tags.join(';'),
                        lists: options.lists.join(";"),
                        description: options.description
                    };
                return self.get(path, params)
                    .pipe(getResultProcessor('listName')())
                    .pipe(self.fetchList)
                    .done(cb);
            };
        };

        this.merge = this.combineLists("merge");
        this.intersect = this.combineLists("intersect");
        this.diff = this.combineLists("diff");

        var getModeller = function(self) { return function(data) {
            var fn = ((Model && function(m) { return new Model(m); }) || IDENTITY);
            self.model = fn(data.model);
            self.model.service = self;
            return MODELS[self.root] = self.model;
        }};

        /**
         * A function that handles a data model.
         * @name ModelHandler
         * @param model {Model} The model to process.
         */

        /**
         * Fetch the definition of the data model from the server.
         *
         * @this {Service}
         * @param cb {ModelHandler} An optional model handling callback.
         * @return {Deferred} A promise to fetch the data-model.
         */
        this.fetchModel = function(cb) {
            if (!this.model && MODELS[this.root]) {
                this.model = MODELS[this.root];
            }
            if (this.model) {
                return Deferred().resolve(this.model).done(cb).promise();
            } else {
                return this.get(MODEL_PATH).pipe(getModeller(this)).done(cb);
            }
        };

        this.fetchSummaryFields = function(cb) {
            var self = this;
            var promise = Deferred();
            if (SUMMARY_FIELDS[self.root]) {
                self.summaryFields = SUMMARY_FIELDS[self.root];
            }
            if (self.summaryFields) {
                cb(self.summaryFields);
                promise.resolve(self.summaryFields);
            } else {
                self.makeRequest(SUMMARYFIELDS_PATH, null, function(data) {
                    self.summaryFields = data.classes;
                    SUMMARY_FIELDS[self.root] = data.classes;
                    cb(self.summaryFields);
                    promise.resolve(self.summaryFields);
                });
            }
            promise.fail(this.errorHandler);
            return promise;
        };

        /**
         * A request to fetch lists that contain an item by their internal ID.
         * @name InternalIDRequest
         * @property {number|string} The Internal ID (should be a valid Java Integer).
         */

        /**
         * A request to fetch lists containing an item by a stable external identifier.
         * @name PublicIdRequest
         * @property {!string} publicId The stable external unique identifier.
         * @property {!string} type The type of the object (eg: "Gene").
         * @property {?string} extraValue An optional extra value to help resolve the object.
         *                                (eg, for a Gene, the Organism name).
         */

        /**
        * Fetch lists containing an item.
        *
        * @param {InternalIDRequest | PublicIdRequest} options Options should contain: 
        * @param {function(Array.<List>)} an optional callback function.
        * @return {Deferred.<Model>} A promise to return a model
        */
        this.fetchListsContaining = function(opts, cb) {
            return this.get(WITH_OBJ_PATH, opts).pipe(listProcessor).done(cb);
        };

        /**
         * Construct a query, and yield it to the callback.
         * @param options The query defined in a JSON structure
         * @param cb The continuation of this function.
         * @return {Deffered} a promise to make a query.
         */
        this.query = function(options, cb) {
            var service = this;
            var promise = Deferred();
            service.fetchModel(function(m) {
                service.fetchSummaryFields(function(sfs) {
                    _.extend(options, {model: m, summaryFields: sfs});
                    var q;
                    try {
                        q = new Query(options, service);
                    } catch (e) {
                        promise.reject(e);
                    }
                    if (cb) {
                        try {
                            cb(q);
                        } catch (e) {
                            promise.reject(e);
                        }
                    }
                    promise.resolve(q);
                }).fail(promise.reject);
            }).fail(promise.reject);
            promise.fail(this.errorHandler);
            return promise;
        };

        this.manageUserPreferences = function(method, data) {
            var service = this;
            return this.fetchVersion().pipe(function(v) {
                if (v >= 11) {
                    return service.makeRequest("user/preferences", data, null, method)
                                  .pipe(function(resp) {return resp.preferences});
                } else {
                    return Deferred().reject('not available',
                        'This service does not provide preferences');
                }
            }, this.errorHandler);
        };

        constructor(properties || {});
    };

    intermine.Service = Service;
    // Re-export out the other classes if being used as the node entrypoint
    if (IS_NODE) {
        intermine.Model = Model;
        intermine.Query = Query;
        intermine.List = List;
        intermine.User = User;
    }
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');

        
// Generated by CoffeeScript 1.3.3
(function() {
  var IS_NODE, Query, conAttrs, conStr, conValStr, concatMap, decapitate, f, fold, get, getListResponseHandler, get_canonical_op, id, idConStr, mth, multiConStr, noValueConStr, partition, root, simpleConStr, take, toQueryString, typeConStr, _, _CLONE, _fn, _get_data_fetcher, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === 'undefined') {
    IS_NODE = false;
    _ = root._;
    _ref = root.intermine.funcutils, partition = _ref.partition, fold = _ref.fold, take = _ref.take, concatMap = _ref.concatMap, id = _ref.id, get = _ref.get;
    _CLONE = function(o) {
      return jQuery.extend(true, {}, o);
    };
    toQueryString = function(req) {
      return jQuery.param(req);
    };
    if (typeof root.console === 'undefined') {
      root.console = {
        log: function() {},
        error: function() {}
      };
    }
    if (root.intermine === 'undefined') {
      root.intermine = {};
    }
    root = root.intermine;
  } else {
    IS_NODE = true;
    _ = require('underscore')._;
    _CLONE = require('clone');
    toQueryString = require('querystring').stringify;
    _ref1 = require('./shiv'), partition = _ref1.partition, fold = _ref1.fold, take = _ref1.take, concatMap = _ref1.concatMap, id = _ref1.id, get = _ref1.get;
  }

  get_canonical_op = function(orig) {
    var canonical;
    canonical = _.isString(orig) ? Query.OP_DICT[orig.toLowerCase()] : null;
    if (!canonical) {
      throw "Illegal constraint operator: " + orig;
    }
    return canonical;
  };

  decapitate = function(x) {
    return x.substr(x.indexOf('.'));
  };

  getListResponseHandler = function(service, cb) {
    return function(data) {
      var name;
      if (cb == null) {
        cb = function() {};
      }
      name = data.listName;
      return service.fetchLists(function(ls) {
        var theList;
        theList = _.find(ls, function(l) {
          return l.name === name;
        });
        return cb(theList);
      });
    };
  };

  conValStr = function(v) {
    return "<value>" + (_.escape(v)) + "</value>";
  };

  conAttrs = function(c, names) {
    var k, v;
    return ((function() {
      var _results;
      _results = [];
      for (k in c) {
        v = c[k];
        if ((__indexOf.call(names, k) >= 0)) {
          _results.push("" + k + "=\"" + (_.escape(v)) + "\" ");
        }
      }
      return _results;
    })()).join('');
  };

  noValueConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code'])) + "/>";
  };

  typeConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'type'])) + "/>";
  };

  simpleConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code', 'value', 'extraValue'])) + "/>";
  };

  multiConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code'])) + ">" + (concatMap(conValStr)(c.values)) + "</constraint>";
  };

  idConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code'])) + "ids=\"" + (c.ids.join(',')) + "\"/>";
  };

  conStr = function(c) {
    var _ref2;
    if (c.values != null) {
      return multiConStr(c);
    } else if (c.ids != null) {
      return idConStr(c);
    } else if (!(c.op != null)) {
      return typeConStr(c);
    } else if (_ref2 = c.op, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
      return noValueConStr(c);
    } else {
      return simpleConStr(c);
    }
  };

  Query = (function() {

    Query.JOIN_STYLES = ['INNER', 'OUTER'];

    Query.BIO_FORMATS = ['gff3', 'fasta', 'bed'];

    Query.NULL_OPS = ['IS NULL', 'IS NOT NULL'];

    Query.ATTRIBUTE_VALUE_OPS = ["=", "!=", ">", ">=", "<", "<=", "CONTAINS", "LIKE", "NOT LIKE"];

    Query.MULTIVALUE_OPS = ['ONE OF', 'NONE OF'];

    Query.TERNARY_OPS = ['LOOKUP'];

    Query.LOOP_OPS = ['=', '!='];

    Query.LIST_OPS = ['IN', 'NOT IN'];

    Query.OP_DICT = {
      "=": "=",
      "==": "=",
      "eq": "=",
      "!=": "!=",
      "ne": "!=",
      ">": ">",
      "gt": ">",
      ">=": ">=",
      "ge": ">=",
      "<": "<",
      "lt": "<",
      "<=": "<=",
      "le": "<=",
      "contains": "CONTAINS",
      "CONTAINS": "CONTAINS",
      "like": "LIKE",
      "LIKE": "LIKE",
      "not like": "NOT LIKE",
      "NOT LIKE": "NOT LIKE",
      "lookup": "LOOKUP",
      "IS NULL": "IS NULL",
      "is null": "IS NULL",
      "IS NOT NULL": "IS NOT NULL",
      "is not null": "IS NOT NULL",
      "ONE OF": "ONE OF",
      "one of": "ONE OF",
      "NONE OF": "NONE OF",
      "none of": "NONE OF",
      "in": "IN",
      "not in": "NOT IN",
      "IN": "IN",
      "NOT IN": "NOT IN",
      "WITHIN": "WITHIN",
      "within": "WITHIN",
      "OVERLAPS": "OVERLAPS",
      "overlaps": "OVERLAPS",
      "ISA": "ISA",
      "isa": "ISA"
    };

    Query.prototype.on = function(events, callback, context) {
      var calls, ev, list, tail, _ref2, _ref3, _ref4;
      events = events.split(/\s+/);
      calls = ((_ref2 = this._callbacks) != null ? _ref2 : this._callbacks = {});
      while (ev = events.shift()) {
        list = ((_ref3 = calls[ev]) != null ? _ref3 : calls[ev] = {});
        tail = ((_ref4 = list.tail) != null ? _ref4 : list.tail = (list.next = {}));
        tail.callback = callback;
        tail.context = context;
        list.tail = tail.next = {};
      }
      return this;
    };

    Query.prototype.bind = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.on.apply(this, args);
    };

    Query.prototype.trigger = function() {
      var all, args, calls, event, events, node, rest, tail;
      events = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      calls = this._callbacks;
      if (!calls) {
        return this;
      }
      all = calls['all'];
      (events = events.split(/\s+/)).push(null);
      while (event = events.shift()) {
        if (all) {
          events.push({
            next: all.next,
            tail: all.tail,
            event: event
          });
        }
        if (!(node = calls[event])) {
          continue;
        }
        events.push({
          next: node.next,
          tail: node.tail
        });
      }
      while (node = events.pop()) {
        tail = node.tail;
        args = node.event ? [node.event].concat(rest) : rest;
        while ((node = node.next) !== tail) {
          node.callback.apply(node.context || this, args);
        }
      }
      return this;
    };

    function Query(properties, service) {
      this.expandStar = __bind(this.expandStar, this);

      this.adjustPath = __bind(this.adjustPath, this);

      var _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      _.defaults(this, {
        constraints: [],
        views: [],
        joins: {},
        constraintLogic: "",
        sortOrder: ""
      });
      if (properties == null) {
        properties = {};
      }
      this.displayNames = (_ref2 = properties.aliases) != null ? _ref2 : {};
      this.service = service != null ? service : {};
      this.model = (_ref3 = properties.model) != null ? _ref3 : {};
      this.summaryFields = (_ref4 = properties.summaryFields) != null ? _ref4 : {};
      this.root = (_ref5 = properties.root) != null ? _ref5 : properties.from;
      this.maxRows = (_ref6 = (_ref7 = properties.size) != null ? _ref7 : properties.limit) != null ? _ref6 : properties.maxRows;
      this.start = (_ref8 = (_ref9 = properties.start) != null ? _ref9 : properties.offset) != null ? _ref8 : 0;
      this.select(properties.views || properties.view || properties.select || []);
      this.addConstraints(properties.constraints || properties.where || []);
      this.addJoins(properties.joins || properties.join || []);
      this.orderBy(properties.sortOrder || properties.orderBy || []);
      if (properties.constraintLogic != null) {
        this.constraintLogic = properties.constraintLogic;
      }
    }

    Query.prototype.removeFromSelect = function(unwanted) {
      var mapFn, so, uw, v;
      unwanted = _.isString(unwanted) ? [unwanted] : unwanted || [];
      mapFn = _.compose(this.expandStar, this.adjustPath);
      unwanted = _.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = unwanted.length; _i < _len; _i++) {
          uw = unwanted[_i];
          _results.push(mapFn(uw));
        }
        return _results;
      })());
      this.sortOrder = (function() {
        var _i, _len, _ref2, _ref3, _results;
        _ref2 = this.sortOrder;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          so = _ref2[_i];
          if (!(_ref3 = so.path, __indexOf.call(unwanted, _ref3) >= 0)) {
            _results.push(so);
          }
        }
        return _results;
      }).call(this);
      this.views = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.views;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          v = _ref2[_i];
          if (!(__indexOf.call(unwanted, v) >= 0)) {
            _results.push(v);
          }
        }
        return _results;
      }).call(this);
      this.trigger('remove:view', unwanted);
      return this.trigger('change:views', this.views);
    };

    Query.prototype.removeConstraint = function(con, silent) {
      var c, iscon, orig, reduced;
      if (silent == null) {
        silent = false;
      }
      orig = this.constraints;
      iscon = typeof con === 'string' ? (function(c) {
        return c.code === con;
      }) : (function(c) {
        var _ref2, _ref3;
        return (c.path === con.path) && (c.op === con.op) && (c.value === con.value) && (c.extraValue === con.extraValue) && (con.type === c.type) && (((_ref2 = c.values) != null ? _ref2.join('%%') : void 0) === ((_ref3 = con.values) != null ? _ref3.join('%%') : void 0));
      });
      reduced = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = orig.length; _i < _len; _i++) {
          c = orig[_i];
          if (!iscon(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (reduced.length !== orig.length - 1) {
        throw "Did not remove a single constraint. original = " + orig + ", reduced = " + reduced;
      }
      this.constraints = reduced;
      if (!silent) {
        this.trigger('change:constraints');
        return this.trigger('removed:constraints', _.difference(orig, reduced));
      }
    };

    Query.prototype.addToSelect = function(views) {
      var p, toAdd, _i, _len, _ref2;
      views = _.isString(views) ? [views] : views || [];
      toAdd = _.map(views, _.compose(this.expandStar, this.adjustPath));
      _ref2 = _.flatten([toAdd]);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        this.views.push(p);
      }
      return this.trigger('add:view change:views', toAdd);
    };

    Query.prototype.select = function(views) {
      this.views = [];
      this.addToSelect(views);
      return this;
    };

    Query.prototype.adjustPath = function(path) {
      path = path && path.name ? path.name : "" + path;
      if (this.root != null) {
        if (!path.match("^" + this.root)) {
          path = this.root + "." + path;
        }
      } else {
        this.root = path.split('.')[0];
      }
      return path;
    };

    Query.prototype._getAllFields = function(table) {
      var attrs, cols, refs;
      attrs = _.values(table.attributes);
      refs = _.values(table.references);
      cols = _.values(table.collections);
      return _.union(attrs, refs, cols);
    };

    Query.prototype._getPaths = function(root, cd, depth) {
      var others, ret, self;
      self = this;
      ret = [root];
      others = [];
      if (cd && depth > 0) {
        others = _.flatten(_.map(cd.fields, function(r) {
          return self._getPaths("" + root + "." + r.name, self.getPathInfo("" + root + "." + r.name).getEndClass(), depth - 1);
        }));
      }
      return ret.concat(others);
    };

    Query.prototype.getPossiblePaths = function(depth) {
      var cd, _base, _ref2, _ref3;
      if (depth == null) {
        depth = 3;
      }
      if ((_ref2 = this._possiblePaths) == null) {
        this._possiblePaths = {};
      }
      cd = this.service.model.classes[this.root];
      return (_ref3 = (_base = this._possiblePaths)[depth]) != null ? _ref3 : _base[depth] = _.flatten(this._getPaths(this.root, cd, depth));
    };

    Query.prototype.getPathInfo = function(path) {
      var adjusted, pi, _ref2;
      adjusted = this.adjustPath(path);
      pi = (_ref2 = this.service.model) != null ? _ref2.getPathInfo(adjusted, this.getSubclasses()) : void 0;
      if (adjusted in this.displayNames) {
        pi.displayName = this.displayNames[adjusted];
      }
      return pi;
    };

    Query.prototype.getSubclasses = function() {
      return fold({}, (function(a, c) {
        if (c.type != null) {
          a[c.path] = c.type;
        }
        return a;
      }))(this.constraints);
    };

    Query.prototype.getType = function(path) {
      return this.getPathInfo(path).getType();
    };

    Query.prototype.getViewNodes = function(path) {
      var toParentNode,
        _this = this;
      toParentNode = function(v) {
        return _this.getPathInfo(v).getParent();
      };
      return _.uniq(_.map(this.views, toParentNode), false, function(n) {
        return n.toPathString();
      });
    };

    Query.prototype.canHaveMultipleValues = function(path) {
      return this.getPathInfo(path).containsCollection();
    };

    Query.prototype.getQueryNodes = function() {
      var constrainedNodes, viewNodes,
        _this = this;
      viewNodes = this.getViewNodes();
      constrainedNodes = _.map(this.constraints, function(c) {
        var pi;
        pi = _this.getPathInfo(c.path);
        if (pi.isAttribute()) {
          return pi.getParent();
        } else {
          return pi;
        }
      });
      return _.uniq(viewNodes.concat(constrainedNodes), false, function(n) {
        return n.toPathString();
      });
    };

    Query.prototype.expandStar = function(path) {
      var cd, expand, fn, n, pathStem;
      if (/\*$/.test(path)) {
        pathStem = path.substr(0, path.lastIndexOf('.'));
        expand = function(x) {
          return pathStem + x;
        };
        cd = this.getType(pathStem);
        if (/\.\*$/.test(path)) {
          if (cd && this.summaryFields[cd.name]) {
            fn = _.compose(expand, decapitate);
            return (function() {
              var _i, _len, _ref2, _results;
              _ref2 = this.summaryFields[cd.name];
              _results = [];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                n = _ref2[_i];
                if (!this.hasView(n)) {
                  _results.push(fn(n));
                }
              }
              return _results;
            }).call(this);
          }
        }
        if (/\.\*\*$/.test(path)) {
          fn = _.compose(expand, function(a) {
            return '.' + a.name;
          });
          return _.uniq(_.union(this.expandStar(pathStem + '.*'), _.map(cd.attributes, fn)));
        }
      }
      return path;
    };

    Query.prototype.isOuterJoin = function(p) {
      return this.joins[this.adjustPath(p)] === 'OUTER';
    };

    Query.prototype.hasView = function(v) {
      return this.views && _.include(this.views, this.adjustPath(v));
    };

    Query.prototype.count = function(cont) {
      if (this.service.count) {
        return this.service.count(this, cont);
      } else {
        throw new Error("This query has no service with count functionality attached.");
      }
    };

    Query.prototype.appendToList = function(target, cb) {
      var name, req, toRun, wrapped;
      name = target && target.name ? target.name : '' + target;
      toRun = this.clone();
      if (toRun.views.length !== 1 || !toRun.views[0].match(/\.id$/)) {
        toRun.select(['id']);
      }
      req = {
        listName: name,
        query: toRun.toXML()
      };
      wrapped = target && target.name ? (function(list) {
        target.size = list.size;
        return cb(list);
      }) : cb;
      return this.service.makeRequest('query/append/tolist', req, getListResponseHandler(this.service, wrapped), 'POST');
    };

    Query.prototype.saveAsList = function(options, cb) {
      var req, toRun;
      toRun = this.clone();
      if (toRun.views.length !== 1 || toRun.views[0] === null || !toRun.views[0].match(/\.id$/)) {
        toRun.select(['id']);
      }
      req = _.clone(options);
      req.listName = req.listName || req.name;
      req.query = toRun.toXML();
      if (options.tags) {
        req.tags = options.tags.join(';');
      }
      return this.service.makeRequest('query/tolist', req, getListResponseHandler(this.service, cb), 'POST');
    };

    Query.prototype.summarise = function(path, limit, cont) {
      return this.filterSummary(path, '', limit, cont);
    };

    Query.prototype.summarize = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.summarise.apply(this, args);
    };

    Query.prototype.filterSummary = function(path, term, limit, cont) {
      var req, toRun;
      if (_.isFunction(limit) && !cont) {
        cont = limit;
        limit = null;
      }
      if (cont == null) {
        cont = function() {};
      }
      path = this.adjustPath(path);
      toRun = this.clone();
      if (!_.include(toRun.views, path)) {
        toRun.views.push(path);
      }
      req = {
        query: toRun.toXML(),
        format: 'jsonrows',
        summaryPath: path
      };
      if (limit) {
        req.size = limit;
      }
      if (term) {
        req.filterTerm = term;
      }
      return this.service.makeRequest('query/results', req, function(data) {
        return cont(data.results, data.uniqueValues, data.filteredCount);
      });
    };

    Query.prototype.clone = function(cloneEvents) {
      var cloned;
      cloned = _CLONE(this);
      if (cloneEvents) {
        cloned._callbacks = this._callbacks;
      } else {
        cloned._callbacks = {};
      }
      return cloned;
    };

    Query.prototype.next = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start + this.maxRows;
      }
      return clone;
    };

    Query.prototype.previous = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start - this.maxRows;
      } else {
        clone.start = 0;
      }
      return clone;
    };

    Query.prototype.getSortDirection = function(path) {
      var dir, so, _i, _len, _ref2;
      path = this.adjustPath(path);
      _ref2 = this.sortOrder;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        so = _ref2[_i];
        if (so.path === path) {
          dir = so.direction;
        }
      }
      return dir;
    };

    Query.prototype.isOuterJoined = function(path) {
      path = this.adjustPath(path);
      return _.any(this.joins, function(d, p) {
        return d === 'OUTER' && path.indexOf(p) === 0;
      });
    };

    Query.prototype.getOuterJoin = function(path) {
      var joinPaths,
        _this = this;
      path = this.adjustPath(path);
      joinPaths = _.sortBy(_.keys(this.joins), get('length')).reverse();
      return _.find(joinPaths, function(p) {
        return _this.joins[p] === 'OUTER' && path.indexOf(p) === 0;
      });
    };

    Query.prototype._parse_sort_order = function(input) {
      var k, so, v;
      so = input;
      if (_.isString(input)) {
        so = {
          path: input,
          direction: 'ASC'
        };
      } else if (!(input.path != null)) {
        k = _.keys(input)[0];
        v = _.values(input)[0];
        so = {
          path: k,
          direction: v
        };
      }
      so.path = this.adjustPath(so.path);
      so.direction = so.direction.toUpperCase();
      return so;
    };

    Query.prototype.addOrSetSortOrder = function(so) {
      var currentDirection, oe, _i, _len, _ref2;
      so = this._parse_sort_order(so);
      currentDirection = this.getSortDirection(so.path);
      if (!(currentDirection != null)) {
        return this.addSortOrder(so);
      } else if (currentDirection !== so.direction) {
        _ref2 = this.sortOrder;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          oe = _ref2[_i];
          if (oe.path === so.path) {
            oe.direction = so.direction;
          }
        }
        return this.trigger('change:sortorder', this.sortOrder);
      }
    };

    Query.prototype.addSortOrder = function(so) {
      this.sortOrder.push(this._parse_sort_order(so));
      this.trigger('add:sortorder', so);
      return this.trigger('change:sortorder', this.sortOrder);
    };

    Query.prototype.orderBy = function(oes) {
      var oe, _i, _len;
      this.sortOrder = [];
      for (_i = 0, _len = oes.length; _i < _len; _i++) {
        oe = oes[_i];
        this.addSortOrder(oe);
      }
      return this.trigger('set:sortorder', this.sortOrder);
    };

    Query.prototype.addJoins = function(joins) {
      var j, k, v, _i, _len, _results, _results1;
      if (_.isArray(joins)) {
        _results = [];
        for (_i = 0, _len = joins.length; _i < _len; _i++) {
          j = joins[_i];
          _results.push(this.addJoin(j));
        }
        return _results;
      } else {
        _results1 = [];
        for (k in joins) {
          v = joins[k];
          _results1.push(this.addJoin({
            path: k,
            style: v
          }));
        }
        return _results1;
      }
    };

    Query.prototype.addJoin = function(join) {
      var _ref2, _ref3, _ref4;
      if (_.isString(join)) {
        join = {
          path: join,
          style: 'OUTER'
        };
      }
      join.path = this.adjustPath(join.path);
      join.style = (_ref2 = (_ref3 = join.style) != null ? _ref3.toUpperCase() : void 0) != null ? _ref2 : join.style;
      if (_ref4 = join.style, __indexOf.call(Query.JOIN_STYLES, _ref4) < 0) {
        throw "Invalid join style: " + join.style;
      }
      this.joins[join.path] = join.style;
      return this.trigger('set:join', join.path, join.style);
    };

    Query.prototype.setJoinStyle = function(path, style) {
      if (style == null) {
        style = 'OUTER';
      }
      path = this.adjustPath(path);
      style = style.toUpperCase();
      if (this.joins[path] !== style) {
        this.joins[path] = style;
        this.trigger('change:joins', {
          path: path,
          style: style
        });
      }
      return this;
    };

    Query.prototype.addConstraints = function(constraints) {
      var c, con, path, _fn, _i, _len,
        _this = this;
      this.__silent__ = true;
      if (_.isArray(constraints)) {
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          c = constraints[_i];
          this.addConstraint(c);
        }
      } else {
        _fn = function(path, con) {
          var constraint, k, keys, v, x, _ref2;
          constraint = {
            path: path
          };
          if (con === null) {
            constraint.op = 'IS NULL';
          } else if (_.isArray(con)) {
            constraint.op = 'ONE OF';
            constraint.values = con;
          } else if (_.isString(con) || _.isNumber(con)) {
            if (_ref2 = typeof con.toUpperCase === "function" ? con.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
              constraint.op = con;
            } else {
              constraint.op = '=';
              constraint.value = con;
            }
          } else {
            keys = (function() {
              var _results;
              _results = [];
              for (k in con) {
                x = con[k];
                _results.push(k);
              }
              return _results;
            })();
            if (__indexOf.call(keys, 'isa') >= 0) {
              if (_.isArray(con.isa)) {
                constraint.op = k;
                constraint.values = con.isa;
              } else {
                constraint.type = con.isa;
              }
            } else {
              if (__indexOf.call(keys, 'extraValue') >= 0) {
                constraint.extraValue = con.extraValue;
              }
              for (k in con) {
                v = con[k];
                if (!(k !== 'extraValue')) {
                  continue;
                }
                constraint.op = k;
                if (_.isArray(v)) {
                  constraint.values = v;
                } else {
                  constraint.value = v;
                }
              }
            }
          }
          return _this.addConstraint(constraint);
        };
        for (path in constraints) {
          con = constraints[path];
          _fn(path, con);
        }
      }
      this.__silent__ = false;
      this.trigger('add:constraint');
      return this.trigger('change:constraints');
    };

    Query.prototype.addConstraint = function(constraint) {
      var a0, conArgs, v, _ref2;
      if (_.isArray(constraint)) {
        conArgs = constraint.slice();
        constraint = {
          path: conArgs.shift()
        };
        if (conArgs.length === 1) {
          a0 = conArgs[0];
          if (_ref2 = typeof a0.toUpperCase === "function" ? a0.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
            constraint.op = a0;
          } else {
            constraint.type = a0;
          }
        } else if (conArgs.length >= 2) {
          constraint.op = conArgs[0];
          v = conArgs[1];
          if (_.isArray(v)) {
            constraint.values = v;
          } else {
            constraint.value = v;
          }
          if (conArgs.length === 3) {
            constraint.extraValue = conArgs[2];
          }
        }
      }
      constraint.path = this.adjustPath(constraint.path);
      if (constraint.type == null) {
        try {
          constraint.op = get_canonical_op(constraint.op);
        } catch (error) {
          throw new Error("Illegal operator: " + constraint.op);
        }
      }
      this.constraints.push(constraint);
      if (!this.__silent__) {
        this.trigger('add:constraint', constraint);
        this.trigger('change:constraints');
      }
      return this;
    };

    Query.prototype.getSorting = function() {
      return this.sortOrder.map(function(oe) {
        return "" + oe.path + " " + oe.direction;
      }).join(' ');
    };

    Query.prototype.getConstraintXML = function() {
      if (this.constraints.length) {
        return concatMap(conStr)(concatMap(id)(partition(function(c) {
          return c.type != null;
        })(this.constraints)));
      } else {
        return '';
      }
    };

    Query.prototype.getJoinXML = function() {
      var p, s, strs;
      strs = (function() {
        var _ref2, _results;
        _ref2 = this.joins;
        _results = [];
        for (p in _ref2) {
          s = _ref2[p];
          if (this.isRelevant(p) && s === 'OUTER') {
            _results.push("<join path=\"" + p + "\" style=\"OUTER\"/>");
          }
        }
        return _results;
      }).call(this);
      return strs.join('');
    };

    Query.prototype.toXML = function() {
      var attrs, headAttrs, k, v;
      attrs = {
        model: this.model.name,
        view: this.views.join(' '),
        sortOrder: this.getSorting(),
        constraintLogic: this.constraintLogic
      };
      headAttrs = ((function() {
        var _results;
        _results = [];
        for (k in attrs) {
          v = attrs[k];
          if (v) {
            _results.push(k + '="' + v + '"');
          }
        }
        return _results;
      })()).join(' ');
      return "<query " + headAttrs + " >" + (this.getJoinXML()) + (this.getConstraintXML()) + "</query>";
    };

    Query.prototype.isRelevant = function(p) {
      var pi, pstr;
      pi = this.getPathInfo(p);
      if (pi) {
        pstr = pi.toPathString();
        return _.any(_.union(this.views, _.pluck(this.constraints, 'path')), function(p) {
          return p.indexOf(pstr) === 0;
        });
      } else {
        return true;
      }
    };

    Query.prototype.fetchCode = function(lang, cb) {
      var req;
      if (cb == null) {
        cb = function() {};
      }
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'json'
      };
      return this.service.makeRequest('query/code', req, function(data) {
        return cb(data.code);
      });
    };

    Query.prototype.getCodeURI = function(lang) {
      var req, _ref2;
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'text'
      };
      if (((_ref2 = this.service) != null ? _ref2.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/code?" + (toQueryString(req));
    };

    Query.prototype.getExportURI = function(format) {
      var req, _ref2;
      if (format == null) {
        format = 'tab';
      }
      if (__indexOf.call(Query.BIO_FORMATS, format) >= 0) {
        return this["get" + (format.toUpperCase()) + "URI"]();
      }
      req = {
        query: this.toXML(),
        format: format
      };
      if (((_ref2 = this.service) != null ? _ref2.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results?" + (toQueryString(req));
    };

    Query.prototype.__bio_req = function(types, n) {
      var olds, toRun,
        _this = this;
      toRun = this.clone();
      olds = toRun.views;
      toRun.views = take(n)(olds.map(function(v) {
        return _this.getPathInfo(v).getParent();
      }).filter(function(p) {
        return _.any(types, function(t) {
          return p.isa(t);
        });
      }).map(function(p) {
        return p.append('primaryIdentifier').toPathString();
      }));
      return {
        query: toRun.toXML(),
        format: 'text'
      };
    };

    Query.prototype._fasta_req = function() {
      return this.__bio_req(["SequenceFeature", 'Protein'], 1);
    };

    Query.prototype._gff3_req = function() {
      return this.__bio_req(['SequenceFeature']);
    };

    Query.prototype._bed_req = Query.prototype._gff3_req;

    return Query;

  })();

  Query.ATTRIBUTE_OPS = _.union(Query.ATTRIBUTE_VALUE_OPS, Query.MULTIVALUE_OPS, Query.NULL_OPS);

  Query.REFERENCE_OPS = _.union(Query.TERNARY_OPS, Query.LOOP_OPS, Query.LIST_OPS);

  _ref2 = Query.BIO_FORMATS;
  _fn = function(f) {
    var getMeth, reqMeth, uriMeth;
    reqMeth = "_" + f + "_req";
    getMeth = "get" + (f.toUpperCase());
    uriMeth = getMeth + "URI";
    Query.prototype[getMeth] = function(cb) {
      var req;
      req = this[reqMeth]();
      if (cb == null) {
        cb = function() {};
      }
      return this.service.makeRequest('query/results/' + f, req, cb, 'POST');
    };
    return Query.prototype[uriMeth] = function(cb) {
      var req, _ref3;
      req = this[reqMeth]();
      if (((_ref3 = this.service) != null ? _ref3.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results/" + f + "?" + (toQueryString(req));
    };
  };
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    f = _ref2[_i];
    _fn(f);
  }

  _get_data_fetcher = function(server_fn) {
    return function(page, cb) {
      if (cb == null) {
        cb = page;
      }
      page = _.isFunction(page) || !page ? {} : page;
      if (this.service[server_fn]) {
        _.defaults(page, {
          start: this.start,
          size: this.maxRows
        });
        return this.service[server_fn](this, page, cb);
      } else {
        throw new Error("Could not find " + server_fn + " at this service. Sorry.");
      }
    };
  };

  _ref3 = ['rowByRow', 'eachRow', 'recordByRecord', 'eachRecord', 'records', 'rows', 'table', 'tableRows'];
  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
    mth = _ref3[_j];
    Query.prototype[mth] = _get_data_fetcher(mth);
  }

  root.Query = Query;

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    var _;
    var TAGS_PATH = "list/tags";
    if (IS_NODE) {
        _ = require('underscore')._;
    } else {
        _ = exports._;
        if (typeof exports.intermine == 'undefined') {
            exports.intermine = {};
        }
        exports = intermine;
    }

    var isFolder = function(t) {
        return t.substr(0, t.indexOf(":")) === '__folder__';
    };
    var getFolderName = function(t) {
        return t.substr(t.indexOf(":") + 1);
    };

    var List = function(properties, service) {

        _(this).extend(properties);
        this.service = service;
        this.dateCreated = this.dateCreated ? new Date(this.dateCreated) : null;

        this.folders = _(this.tags).chain()
                                   .filter(isFolder)
                                   .map(getFolderName)
                                   .value();

        /**
         * Does this list have a given tag?
         *
         * @param t the tag this list may or may not have
         * @return Boolean whether or not this list has a given tag.
         */
        this.hasTag = function(t) {
            return _(this.tags).include(t);
        };

        /**
         * Delete this list. 
         *
         * The list MUST not be used after this function has been called.
         * @param cb a function to call upon completion of this action
         * @return jQuery.Deferred
         */
        this.del = function(cb) {
            cb = cb || function() {};
            return this.service.makeRequest("lists", 
                {name: this.name}, cb, "DELETE");
        };

        /**
         * Get the contents of this list.
         *
         * Each item in the list will be returned as an object with the summary-fields selected.
         * The results are unordered.
         * @param cb A function (optional) to call on completion of this action (default = no-op)
         * @return jQuery.Deferred
         */
        this.contents = function(cb) {
            cb = cb || function() {};
            var query = {select: ["*"], from: this.type, where: {}};
            query.where[this.type] = {IN: this.name};
            return this.service.query(query, function(q) {
                q.records(cb);
            });
        };

        /**
         * Get enrichment statistics for this list.
         *
         * @see intermine.service#enrichment
         * @param data A map of key-value terms with the following keys: 'widget', 'maxp', 'correction', and optionally 'filter' and 'population'.
         * @param cb a function of the type [(results) -> void] to call on completion of this request.
         * @return jQuery.Deferred
         */
        this.enrichment = function(data, cb) {
            data.list = this.name;
            return this.service.enrichment(data, cb);
        };

        this.shareWithUser = function(recipient, cb) {
            var data = {'list': this.name, 'with': recipient};
            return this.service.makeRequest('lists/shares', data, cb, 'POST');
        };

        this.inviteUserToShare = function(recipient, cb) {
            var data = {'list': this.name, 'to': recipient, 'notify': true};
            return this.service.makeRequest("lists/invitations", data, cb, 'POST');
        };

    };

    exports.List = List;
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');
        
